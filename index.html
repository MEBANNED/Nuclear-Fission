<!DOCTYPE HTML>
<html lang="en-US">
<head>
    <meta charset="UTF-8"><!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Retro Space Shooter Low-Score Grind</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap');
        
        body {
            margin: 0;
            overflow: hidden;
            background-color: #0f172a;
            font-family: 'Press Start 2P', cursive;
            touch-action: none;
            user-select: none;
            -webkit-user-select: none;
        }

        #gameCanvas {
            display: block;
            width: 100%;
            height: 100vh;
        }

        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            padding: 20px;
            box-sizing: border-box;
        }

        .hud-text {
            color: white;
            text-shadow: 2px 2px 0 #000;
            font-size: 16px;
            z-index: 5;
        }

        #start-screen, #game-over-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(15, 23, 42, 0.9);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            pointer-events: auto;
            z-index: 10;
            text-align: center;
        }

        .btn {
            background: #3b82f6; /* Blue for start */
            border: 4px solid #1d4ed8;
            color: white;
            padding: 20px 40px;
            font-family: 'Press Start 2P', cursive;
            font-size: 18px;
            cursor: pointer;
            margin-top: 20px;
            transition: transform 0.1s;
            text-transform: uppercase;
            box-shadow: 0 6px 0 #1e3a8a;
        }

        .btn:active {
            transform: scale(0.95) translateY(4px);
            box-shadow: 0 2px 0 #1e3a8a;
        }
        
        #restartBtn {
            background: #ef4444;
            border-color: #b91c1c;
            box-shadow: 0 6px 0 #7f1d1d;
        }

        .hidden {
            display: none !important;
        }
    </style>
</head>
<body>

    <!-- Canvas Layer -->
    <canvas id="gameCanvas"></canvas>

    <!-- UI Layer -->
    <div id="ui-layer">
        <div class="flex justify-between w-full">
            <div class="hud-text text-yellow-400">SCORE: <span id="scoreEl">0</span></div>
            <div class="hud-text text-red-400">LIVES: <span id="livesEl">3</span></div>
        </div>
    </div>

    <!-- Start Screen -->
    <div id="start-screen">
        <h1 class="text-4xl md:text-6xl text-cyan-400 mb-6" style="text-shadow: 4px 4px 0 #1e3a8a; line-height: 1.5;">NEON<br>DEFENDER</h1>
        <p class="text-gray-300 mb-8 text-xs md:text-sm leading-6 max-w-md px-4">
            <span class="text-yellow-400">CONTROLS</span><br><br>
            Desktop: Arrow Keys to Move. <span class="text-green-300 font-bold">SHIP AUTOFIRING.</span><br>
            Mobile: Drag to Move (Autofire is always active)<br>
            <br><span class="text-red-400 font-bold">1 POINT PER HIT!</span>
        </p>
        <button class="btn" id="startBtn">LAUNCH SHIP</button>
    </div>

    <!-- Game Over Screen -->
    <div id="game-over-screen" class="hidden">
        <h1 class="text-4xl md:text-5xl text-red-500 mb-6" style="text-shadow: 4px 4px 0 #fff;">GAME OVER</h1>
        <p class="text-white mb-6 text-xl">SCORE: <span id="finalScore">0</span></p>
        <button class="btn" id="restartBtn">RETRY</button>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        // UI Elements
        const scoreEl = document.getElementById('scoreEl');
        const livesEl = document.getElementById('livesEl');
        const finalScoreEl = document.getElementById('finalScore');
        const startScreen = document.getElementById('start-screen');
        const gameOverScreen = document.getElementById('game-over-screen');
        const startBtn = document.getElementById('startBtn');
        const restartBtn = document.getElementById('restartBtn');

        // Game State
        let gameRunning = false;
        let score = 0;
        let lives = 3;
        let frame = 0;
        let animationId;
        let width, height;

        // Entity Arrays
        let player;
        let projectiles = [];
        let enemies = [];
        let particles = [];
        let stars = [];

        // Inputs
        const keys = {
            ArrowLeft: false,
            ArrowRight: false,
            // Spacebar and mouse input are now ignored for shooting
        };
        
        const mouse = { x: 0, y: 0, isDown: false };

        // Setup Canvas
        function resize() {
            width = window.innerWidth;
            height = window.innerHeight;
            canvas.width = width;
            canvas.height = height;
            if(player) {
                player.y = height - 100;
                // Keep player in bounds on resize
                if(player.x > width - player.width) player.x = width - player.width;
            }
        }
        window.addEventListener('resize', resize);
        // Initial Call
        width = window.innerWidth;
        height = window.innerHeight;
        canvas.width = width;
        canvas.height = height;

        // --- Classes ---

        class Star {
            constructor() {
                this.x = Math.random() * width;
                this.y = Math.random() * height;
                this.size = Math.random() * 2.5;
                this.speed = Math.random() * 2 + 0.5;
                this.brightness = Math.random();
            }
            update() {
                this.y += this.speed;
                if (this.y > height) {
                    this.y = 0;
                    this.x = Math.random() * width;
                }
            }
            draw() {
                ctx.fillStyle = `rgba(255, 255, 255, ${this.brightness})`;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        class Player {
            constructor() {
                this.width = 50;
                this.height = 50;
                this.x = width / 2 - this.width / 2;
                this.y = height - 100;
                this.speed = 8;
                this.color = '#3b82f6'; // Blue
                this.cooldown = 0;
                this.flashFrames = 0;
            }

            update() {
                // Keyboard movement
                if (keys.ArrowLeft && this.x > 0) this.x -= this.speed;
                if (keys.ArrowRight && this.x < width - this.width) this.x += this.speed;

                // Mouse/Touch movement
                if (mouse.isDown) {
                    const targetX = mouse.x - this.width/2;
                    // Smooth lerp for better feel
                    this.x += (targetX - this.x) * 0.15;
                    
                    // Hard clamp boundaries
                    if(this.x < 0) this.x = 0;
                    if(this.x > width - this.width) this.x = width - this.width;
                }

                // Shooting Logic
                if (this.cooldown > 0) this.cooldown--;
                
                // *** MODIFICATION: Always fire if cooldown is ready (Continuous Fire) ***
                if (this.cooldown <= 0) {
                    this.shoot();
                    this.cooldown = 15; // Fire rate cooldown (fires every 15 frames)
                }
            }

            shoot() {
                // Add bullet slightly above player
                projectiles.push(new Projectile(this.x + this.width / 2, this.y));
                
                // Muzzle flash visual state
                this.flashFrames = 3;

                // Recoil effect
                this.y += 4;
                setTimeout(() => { if(gameRunning) this.y -= 4; }, 40);
            }

            draw() {
                // Muzzle Flash
                if (this.flashFrames > 0) {
                    ctx.fillStyle = '#fff';
                    ctx.beginPath();
                    ctx.arc(this.x + this.width/2, this.y - 10, 15, 0, Math.PI * 2);
                    ctx.fill();
                    this.flashFrames--;
                }

                ctx.fillStyle = this.color;
                
                // Main Body
                ctx.beginPath();
                ctx.moveTo(this.x + this.width/2, this.y); // Nose
                ctx.lineTo(this.x + this.width, this.y + this.height); // Bottom Right
                ctx.lineTo(this.x + this.width/2, this.y + this.height - 15); // Center Indent
                ctx.lineTo(this.x, this.y + this.height); // Bottom Left
                ctx.closePath();
                ctx.fill();

                // Engine Glow
                ctx.shadowBlur = 20;
                ctx.shadowColor = '#60a5fa';
                ctx.fillStyle = '#93c5fd';
                ctx.beginPath();
                ctx.moveTo(this.x + 15, this.y + this.height - 5);
                ctx.lineTo(this.x + this.width - 15, this.y + this.height - 5);
                ctx.lineTo(this.x + this.width/2, this.y + this.height + 15 + (Math.random()*5));
                ctx.fill();
                ctx.shadowBlur = 0;
            }
        }

        class Projectile {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.size = 12; // Square size
                this.speed = 7; // Heavy shot speed
                this.color = '#a855f7'; // Purple/Violet
                this.markedForDeletion = false;
            }

            update() {
                this.y -= this.speed;
                // Delete if off screen
                if (this.y < -20) this.markedForDeletion = true;
            }

            draw() {
                ctx.save();
                ctx.shadowBlur = 20; // Increased glow
                ctx.shadowColor = this.color;
                ctx.fillStyle = this.color;
                
                // Square shape
                ctx.fillRect(this.x - this.size/2, this.y - this.size/2, this.size, this.size);
                
                // Add a white core for "plasma" look
                ctx.fillStyle = '#fff';
                const coreSize = this.size / 2;
                ctx.fillRect(this.x - coreSize/2, this.y - coreSize/2, coreSize, coreSize);

                ctx.restore();
            }
        }

        class Enemy {
            constructor() {
                this.width = 40;
                this.height = 40;
                this.x = Math.random() * (width - this.width);
                this.y = -this.height;
                // Smoother speed scaling based on score
                this.speed = Math.random() * 2 + 3 + (score * 0.0005); 
                this.color = '#ef4444'; // Red
                this.markedForDeletion = false;
                this.angle = 0;
            }

            update() {
                this.y += this.speed;
                this.angle += 0.1; // Spin effect

                if (this.y > height) {
                    this.markedForDeletion = true;
                    updateLives(-1);
                }
            }

            draw() {
                ctx.save();
                ctx.translate(this.x + this.width/2, this.y + this.height/2);
                ctx.rotate(this.angle); // Spin
                ctx.fillStyle = this.color;
                
                // Diamond shape
                ctx.beginPath();
                ctx.moveTo(0, -this.height/2);
                ctx.lineTo(this.width/2, 0);
                ctx.lineTo(0, this.height/2);
                ctx.lineTo(-this.width/2, 0);
                ctx.closePath();
                
                ctx.shadowBlur = 10;
                ctx.shadowColor = '#b91c1c';
                ctx.fill();
                ctx.restore();
            }
        }

        class Particle {
            constructor(x, y, color) {
                this.x = x;
                this.y = y;
                this.radius = Math.random() * 4 + 1;
                this.speedX = (Math.random() - 0.5) * 8;
                this.speedY = (Math.random() - 0.5) * 8;
                this.color = color;
                this.alpha = 1;
                this.markedForDeletion = false;
            }

            update() {
                this.x += this.speedX;
                this.y += this.speedY;
                this.alpha -= 0.02; // Fade out
                if (this.alpha <= 0) this.markedForDeletion = true;
            }

            draw() {
                ctx.save();
                ctx.globalAlpha = this.alpha;
                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
            }
        }

        // --- Input Handling ---
        // Only track movement keys now
        window.addEventListener('keydown', e => {
            if(e.code === 'ArrowLeft') keys.ArrowLeft = true;
            if(e.code === 'ArrowRight') keys.ArrowRight = true;
            // Removed spacebar for shooting
        });

        window.addEventListener('keyup', e => {
            if(e.code === 'ArrowLeft') keys.ArrowLeft = false;
            if(e.code === 'ArrowRight') keys.ArrowRight = false;
        });

        // Mouse & Touch
        const updateMouse = (e) => {
            const clientX = e.touches ? e.touches[0].clientX : e.clientX;
            const clientY = e.touches ? e.touches[0].clientY : e.clientY;
            mouse.x = clientX;
            mouse.y = clientY;
        };

        window.addEventListener('mousedown', (e) => { mouse.isDown = true; updateMouse(e); });
        window.addEventListener('mousemove', (e) => { if(mouse.isDown) updateMouse(e); });
        window.addEventListener('mouseup', () => { mouse.isDown = false; });

        // Passive false required to prevent scrolling while playing
        window.addEventListener('touchstart', (e) => { mouse.isDown = true; updateMouse(e); }, {passive: false});
        window.addEventListener('touchmove', (e) => { 
            if(mouse.isDown) updateMouse(e); 
            e.preventDefault(); 
        }, {passive: false});
        window.addEventListener('touchend', () => { mouse.isDown = false; });


        // --- Game Logic ---

        function spawnEnemy() {
            // Spawn rate is now much faster and ramps up quicker
            let rate = 30; // Initial spawn rate (was 50)
            if(score > 10) rate = 25; // Ramps up faster
            if(score > 25) rate = 20; // Maximum speed achieved earlier

            if (frame % rate === 0) { 
                enemies.push(new Enemy());
            }
        }

        function createExplosion(x, y, color) {
            for(let i = 0; i < 12; i++) {
                particles.push(new Particle(x, y, color));
            }
        }

        function updateLives(amount) {
            lives += amount;
            livesEl.innerText = lives;
            if (lives <= 0) gameOver();
            
            if(amount < 0) {
                // Screen Shake
                canvas.style.transform = `translate(${Math.random()*10-5}px, ${Math.random()*10-5}px)`;
                setTimeout(() => canvas.style.transform = 'none', 80);
            }
        }

        function checkCollisions() {
            // Bullet vs Enemy
            projectiles.forEach(projectile => {
                enemies.forEach(enemy => {
                    if (!enemy.markedForDeletion && !projectile.markedForDeletion) {
                        // Using a simple AABB check since projectiles are now square
                        const projCenterX = projectile.x;
                        const projCenterY = projectile.y;
                        const projSize = projectile.size;
                        
                        const enemyCenterX = enemy.x + enemy.width/2;
                        const enemyCenterY = enemy.y + enemy.height/2;
                        
                        // Treat diamond enemy as a circle with radius width/2 for simplicity
                        const dist = Math.hypot(projCenterX - enemyCenterX, projCenterY - enemyCenterY);

                        if (dist < enemy.width/2 + projSize/2) {
                            enemy.markedForDeletion = true;
                            projectile.markedForDeletion = true;
                            // 1 point per hit
                            score += 1; 
                            scoreEl.innerText = score;
                            createExplosion(enemyCenterX, enemyCenterY, '#ef4444');
                            createExplosion(enemyCenterX, enemyCenterY, '#fff');
                        }
                    }
                });
            });

            // Player vs Enemy
            enemies.forEach(enemy => {
                if(!enemy.markedForDeletion) {
                    const dist = Math.hypot(player.x + player.width/2 - (enemy.x + enemy.width/2), player.y + player.height/2 - (enemy.y + enemy.height/2));
                    if (dist < player.width/2 + enemy.width/3) {
                        enemy.markedForDeletion = true;
                        updateLives(-1);
                        createExplosion(enemy.x + enemy.width/2, enemy.y + enemy.height/2, '#fff');
                        createExplosion(player.x + player.width/2, player.y + player.height/2, '#3b82f6');
                    }
                }
            });
        }

        // Main Loop
        function animate() {
            if (!gameRunning) return;

            // Clear with trail effect
            ctx.fillStyle = 'rgba(15, 23, 42, 0.3)'; 
            ctx.fillRect(0, 0, width, height);

            // 1. Background
            stars.forEach(star => {
                star.update();
                star.draw();
            });

            // 2. Player
            player.update();
            player.draw();

            // 3. Projectiles (Reverse loop to fix skipping bug)
            for (let i = projectiles.length - 1; i >= 0; i--) {
                const p = projectiles[i];
                p.update();
                p.draw();
                if (p.markedForDeletion) {
                    projectiles.splice(i, 1);
                }
            }

            // 4. Enemies (Reverse loop)
            for (let i = enemies.length - 1; i >= 0; i--) {
                const e = enemies[i];
                e.update();
                e.draw();
                if (e.markedForDeletion) {
                    enemies.splice(i, 1);
                }
            }

            // 5. Particles (Reverse loop)
            for (let i = particles.length - 1; i >= 0; i--) {
                const p = particles[i];
                p.update();
                p.draw();
                if (p.markedForDeletion) {
                    particles.splice(i, 1);
                }
            }

            spawnEnemy();
            checkCollisions();

            frame++;
            animationId = requestAnimationFrame(animate);
        }

        function initGame() {
            score = 0;
            lives = 3;
            frame = 0;
            scoreEl.innerText = score;
            livesEl.innerText = lives;
            
            // Reset arrays
            projectiles = [];
            enemies = [];
            particles = [];
            
            player = new Player();
            gameRunning = true;
            
            startScreen.classList.add('hidden');
            gameOverScreen.classList.add('hidden');
            
            animate();
        }

        function gameOver() {
            gameRunning = false;
            cancelAnimationFrame(animationId);
            finalScoreEl.innerText = score;
            gameOverScreen.classList.remove('hidden');
        }

        startBtn.addEventListener('click', initGame);
        restartBtn.addEventListener('click', initGame);

        // Background animation for Start Screen
        resize();
        stars = [];
        for(let i=0; i<60; i++) stars.push(new Star());
        
        function bgAnimate() {
            if(gameRunning) return;
            ctx.fillStyle = 'rgba(15, 23, 42, 0.4)';
            ctx.fillRect(0, 0, width, height);
            stars.forEach(star => {
                star.update();
                star.draw();
            });
            requestAnimationFrame(bgAnimate);
        }
        bgAnimate();

    </script>
</body>
</html>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Nuclear Fission</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000000; font-family: 'Comic Sans MS', sans-serif; }
        canvas { display: block; }
        #controls {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 100;
            display: flex;
            gap: 10px;
        }
        button {
            background-color: #4F46E5; /* Indigo */
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 12px;
            font-size: 16px;
            cursor: pointer;
            transition: all 0.2s;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.2);
            font-weight: 600;
            text-transform: uppercase;
        }
        button:hover {
            background-color: #6366F1;
            box-shadow: 0 6px 8px rgba(0, 0, 0, 0.3);
            transform: translateY(-1px);
        }
        button:active {
            background-color: #4338CA;
            transform: translateY(1px);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }
        #info {
            position: absolute;
            bottom: 20px;
            left: 20px;
            color: #ffffff;
            background-color: rgba(0, 0, 0, 0.6);
            padding: 10px 15px;
            border-radius: 8px;
            font-size: 14px;
        }
    </style>
</head>
<body>
    <div id="controls">
        <button id="startButton">Start Reaction</button>
    </div>
    <div id="info">
        <p>Atoms Fissioned: <span id="fissionCount">0</span></p>
        <p>Neutrons in Motion: <span id="neutronCount">0</span></p>
    </div>

    <!-- Three.js CDN --><script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <!-- Orbit Controls for better camera movement --><script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <!-- GSAP CDN for smooth explosion effects --><script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.9.1/gsap.min.js"></script>


    <script>
        // --- CONSTANTS AND GLOBAL SETUP ---
        const NEUTRON_COUNT_RELEASED = 2; // Confirmed at 2 per user request
        const FISSION_PRODUCT_VELOCITY = 0.5;
        // Adjusted neutron velocity for criticality
        const NEUTRON_VELOCITY = 0.3; 
        // NEW: Much faster initial speed to guarantee an instant visual strike
        const INITIAL_LAUNCH_VELOCITY = 20.0; 
        
        const ATOM_GRID_SIZE = 6; 
        const URANIUM_RADIUS = 3.0; 
        // Adjusted spacing for higher criticality
        const SPACING = URANIUM_RADIUS * 2.05; 
        const BOUNDARY = (ATOM_GRID_SIZE / 2) * SPACING * 1.5;

        // Increased speed multiplier for main particles (neutrons, fission products)
        const SIMULATION_SPEED_MULTIPLIER = 25; 

        // CRITICAL FIX: Increased collision margin to prevent fast-moving neutrons from "tunneling" through atoms.
        const COLLISION_MARGIN = 4.0; 

        // New constant for random neutron loss (simulating general absorption or leakage)
        // This is the "now and then" disappearance requested by the user.
        const RANDOM_ABSORPTION_CHANCE_PER_FRAME = 0.005; // 0.5% chance per frame for a neutron to disappear

        // Simulation control variables
        let reactionStartTime = null;
        let currentFissionLimit = 0; // This variable now holds the random limit (125-175) for the current run
        const TIME_LIMIT_SECONDS = 7;
        let isReactionOver = false;

        // --- CORE THREE.JS SETUP ---
        
        if (THREE.Vector3.prototype.randomDirection === undefined) {
            THREE.Vector3.prototype.randomDirection = function () {
                var phi = Math.random() * 2 * Math.PI;
                var theta = Math.acos(Math.random() * 2 - 1);
                
                var x = Math.sin(theta) * Math.cos(phi);
                var y = Math.sin(theta) * Math.sin(phi);
                var z = Math.cos(theta);

                this.set(x, y, z).normalize();
                return this;
            };
        }

        let scene, camera, renderer, controls;
        let atoms = [];
        let particles = [];
        let explosionParticles = []; 
        let stats = {
            fissionCount: 0,
            neutronCount: 0
        };

        const materials = {
            uranium: new THREE.MeshPhongMaterial({ color: 0x6EE7B7, emissive: 0x00FF00, emissiveIntensity: 0.7, transparent: true, opacity: 1.0, shininess: 80 }), 
            neutron: new THREE.MeshPhongMaterial({ color: 0x93C5FD, emissive: 0x00FFFF, emissiveIntensity: 1.0, shininess: 90 }), 
            strontium: new THREE.MeshPhongMaterial({ color: 0xFF7F50, emissive: 0xFF4500, emissiveIntensity: 0.5, shininess: 50 }), 
            xenon: new THREE.MeshPhongMaterial({ color: 0xFFD700, emissive: 0xFFD700, emissiveIntensity: 0.5, shininess: 50 }), 
            explosionParticle: new THREE.MeshBasicMaterial({ color: 0xFF4500, transparent: true, opacity: 1, blending: THREE.AdditiveBlending }), 
        };

        // --- PARTICLE CLASSES ---

        class UraniumAtom {
            constructor(x, y, z) {
                this.isFissile = true;
                this.radius = URANIUM_RADIUS;
                this.mesh = new THREE.Mesh(new THREE.SphereGeometry(this.radius, 16, 16), materials.uranium.clone());
                this.mesh.position.set(x, y, z);
                scene.add(this.mesh);
            }

            destroy() {
                this.isFissile = false;
                scene.remove(this.mesh);
                this.mesh.geometry.dispose();
                this.mesh.material.dispose();
            }
        }

        class MovingParticle {
            constructor(type, position, velocity, radius, material) {
                this.type = type; 
                this.velocity = new THREE.Vector3().copy(velocity);
                this.radius = radius;
                this.mesh = new THREE.Mesh(new THREE.SphereGeometry(radius, 8, 8), material.clone());
                this.mesh.position.copy(position);
                scene.add(this.mesh);
            }

            update(deltaTime) {
                // deltaTime is already scaled by SIMULATION_SPEED_MULTIPLIER
                this.mesh.position.addScaledVector(this.velocity, deltaTime);

                // *** RANDOM ABSORPTION/LOSS LOGIC (The "now and then" disappearance) ***
                if (this.type === 'neutron' && Math.random() < RANDOM_ABSORPTION_CHANCE_PER_FRAME) {
                    this.destroy(); 
                    return; 
                }

                // Boundary check (standard leakage)
                if (this.mesh.position.length() > BOUNDARY * 1.5) {
                    this.destroy();
                    // Explicitly stop processing after destruction due to leakage
                    return; 
                }
            }

            destroy() {
                const index = particles.indexOf(this);
                if (index > -1) {
                    particles.splice(index, 1);
                }
                scene.remove(this.mesh);
                this.mesh.geometry.dispose();
                this.mesh.material.dispose();

                if (this.type === 'neutron') {
                    stats.neutronCount--;
                }
            }
        }

        // New class for short-lived explosion fragments (The Fireball components)
        class ExplosionParticle {
            constructor(position, color, size, speed) {
                // Slightly larger base geometry for a fuller look (increased size * 1.0)
                this.mesh = new THREE.Mesh(new THREE.SphereGeometry(size * 1.0, 8, 8), materials.explosionParticle.clone()); 
                this.mesh.position.copy(position);
                this.mesh.material.color.set(color);
                scene.add(this.mesh);

                this.velocity = new THREE.Vector3().randomDirection().multiplyScalar(speed * (0.8 + Math.random()));
                this.life = 0; 
                // MaxLife for sustained, lingering effect (0.3 to 0.8 seconds)
                this.maxLife = 0.3 + Math.random() * 0.5; 

                // GSAP animation for fading and scaling
                gsap.to(this.mesh.material, { opacity: 0, duration: this.maxLife, ease: "power1.out" });
                gsap.to(this.mesh.scale, { x: 0.01, y: 0.01, z: 0.01, duration: this.maxLife, ease: "power1.out" }); // Fade scale
            }

            update(deltaTime) {
                // Explosion movement is kept at factor 10 to maintain visual speed consistency
                this.mesh.position.addScaledVector(this.velocity, deltaTime * 10); 
                this.life += deltaTime;
                return this.life >= this.maxLife; // Return true if particle is dead
            }

            destroy() {
                scene.remove(this.mesh);
                this.mesh.geometry.dispose();
                this.mesh.material.dispose();
            }
        }

        function createFuelCore() {
            for (let i = 0; i < ATOM_GRID_SIZE; i++) {
                for (let j = 0; j < ATOM_GRID_SIZE; j++) {
                    for (let k = 0; k < ATOM_GRID_SIZE; k++) {
                        const x = (i - ATOM_GRID_SIZE / 2 + 0.5) * SPACING;
                        const y = (j - ATOM_GRID_SIZE / 2 + 0.5) * SPACING;
                        const z = (k - ATOM_GRID_SIZE / 2 + 0.5) * SPACING;
                        atoms.push(new UraniumAtom(x, y, z));
                    }
                }
            }
        }

        function performFission(atom, neutron) {
            // Do not perform new fissions if the reaction is over
            if (isReactionOver) return; 

            stats.fissionCount++;
            
            // Check against the randomly set fission limit for the current run
            if (stats.fissionCount >= currentFissionLimit) {
                isReactionOver = true;
            }

            const fissionPosition = atom.mesh.position.clone();

            atom.destroy();
            neutron.destroy();

            // *** Enhanced Explosion Effect (Fireball style) ***
            // Increased density up to 200 particles
            const numExplosionParticles = 150 + Math.floor(Math.random() * 50); 
            for (let i = 0; i < numExplosionParticles; i++) {
                // HSL color range focused on yellow, orange, and red (Hue: 0.0 to 0.1)
                const hue = Math.random() * 0.1; // 0.0 (red) to 0.1 (orange/yellow)
                const saturation = 0.8 + Math.random() * 0.2; // High saturation
                const lightness = 0.6 + Math.random() * 0.4; // High lightness for glow
                const color = new THREE.Color().setHSL(hue, saturation, lightness); 
                const size = 0.4 + Math.random() * 0.4; // Larger initial size
                const speed = 2 + Math.random() * 3; // Base speed for movement
                explosionParticles.push(new ExplosionParticle(fissionPosition.clone(), color, size, speed));
            }

            // Fission products still fly apart randomly
            const baseDir = new THREE.Vector3().randomDirection().normalize();
            const productDir1 = baseDir.clone().multiplyScalar(FISSION_PRODUCT_VELOCITY);
            const productDir2 = baseDir.clone().negate().multiplyScalar(FISSION_PRODUCT_VELOCITY * 0.8);

            particles.push(new MovingParticle('fission_product', fissionPosition.clone(), productDir1, 0.6, materials.strontium));
            particles.push(new MovingParticle('fission_product', fissionPosition.clone(), productDir2, 0.9, materials.xenon));

            // NEW LOGIC: Calculate direction vector pointing towards the origin (center of the fuel core)
            const centerDirection = new THREE.Vector3()
                .copy(fissionPosition)
                .negate()
                .normalize();

            for (let i = 0; i < NEUTRON_COUNT_RELEASED; i++) {
                // Apply a slight random scattering/perturbation to the center-seeking direction.
                // Reduced scatter to 0.1 for much stronger inward focus and higher criticality.
                const scatter = new THREE.Vector3().randomDirection().multiplyScalar(0.1); 
                const finalDirection = centerDirection.clone().add(scatter).normalize();
                
                // Use the standard NEUTRON_VELOCITY for subsequent fissions
                const neutronDir = finalDirection.multiplyScalar(NEUTRON_VELOCITY); 
                particles.push(new MovingParticle('neutron', fissionPosition.clone(), neutronDir, 0.3, materials.neutron));
                stats.neutronCount++;
            }
        }

        // --- SIMULATION LOGIC ---

        function checkCollisions() {
            // Only check collisions if the reaction is not over
            if (isReactionOver) return; 

            const remainingAtoms = atoms.filter(a => a.isFissile);
            const neutrons = particles.filter(p => p.type === 'neutron');
            const fissions = [];

            for (const neutron of neutrons) {
                if (particles.indexOf(neutron) === -1) continue; 
                
                for (let i = remainingAtoms.length - 1; i >= 0; i--) {
                    const atom = remainingAtoms[i];
                    const distance = neutron.mesh.position.distanceTo(atom.mesh.position);

                    // Use the increased COLLISION_MARGIN to prevent tunneling
                    if (distance < atom.radius + neutron.radius + COLLISION_MARGIN) {
                        fissions.push({ atom, neutron });
                        break; 
                    }
                }
            }
            fissions.forEach(({ atom, neutron }) => performFission(atom, neutron));
        }

        // --- INITIALIZATION AND ANIMATION LOOP ---

        function init() {
            scene = new THREE.Scene();
            scene.fog = new THREE.Fog(0x000000, BOUNDARY * 0.5, BOUNDARY * 1.2);

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            // Adjusted camera position to be closer to the atom grid for better visibility
            camera.position.z = BOUNDARY * 1.2; 

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);

            // Added stronger ambient light to compensate for the removed dynamic point lights
            scene.add(new THREE.AmbientLight(0x666666)); 
            
            const mainLight = new THREE.PointLight(0xffffff, 2.5, 0); 
            mainLight.position.set(0, 0, BOUNDARY * 0.8);
            scene.add(mainLight);
            
            const secondLight = new THREE.PointLight(0xffffff, 1.5, 0); 
            secondLight.position.set(0, BOUNDARY * 0.5, -BOUNDARY * 0.5);
            scene.add(secondLight);

            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.screenSpacePanning = false;
            controls.minDistance = 30;
            controls.maxDistance = BOUNDARY * 3; 

            resetSimulation();

            document.getElementById('startButton').addEventListener('click', startReaction);
            // Removed the redundant resetButton listener
            window.addEventListener('resize', onWindowResize, false);
        }

        function resetSimulation() {
            atoms.forEach(a => a.destroy());
            particles.forEach(p => p.destroy());
            explosionParticles.forEach(ep => ep.destroy()); 

            atoms = [];
            particles = [];
            explosionParticles = []; 
            stats.fissionCount = 0;
            stats.neutronCount = 0;

            reactionStartTime = null; // Reset the timer
            isReactionOver = false;  // Reset the state

            // Set random fission limit between 125 and 175
            const minLimit = 125;
            const maxLimit = 175;
            currentFissionLimit = Math.floor(Math.random() * (maxLimit - minLimit + 1)) + minLimit; 

            createFuelCore();
            updateInfoDisplay();
            
            document.getElementById('startButton').disabled = false;
            document.getElementById('startButton').innerText = 'Start Reaction';
        }

        // Helper function to force-remove all remaining neutrons and reset the counter
        function cleanupFrozenNeutrons() {
            let removedCount = 0;
            // Iterate backwards to safely destroy all remaining 'neutron' particles.
            for (let i = particles.length - 1; i >= 0; i--) {
                if (particles[i].type === 'neutron') {
                    // Calling destroy() handles removal from the scene and particles array
                    particles[i].destroy(); 
                    removedCount++;
                }
            }
            
            // Ensure the counter is truly zero after cleanup, compensating for any potential missed decrements.
            if (stats.neutronCount !== 0) {
                 console.warn(`[Cleanup] Correcting neutron count from ${stats.neutronCount} to 0. Removed ${removedCount} lingering particles.`);
            } else {
                 console.log(`[Cleanup] Successfully removed ${removedCount} lingering neutron particles.`);
            }
            
            stats.neutronCount = 0; 
            // CRITICAL FIX: Update the display element directly and immediately for an instant visual 0.
            document.getElementById('neutronCount').innerText = 0; 
        }

        function startReaction() {
            const startButton = document.getElementById('startButton');

            // If the reaction is over or depleted, clicking 'Start' button triggers a reset
            if (stats.fissionCount > 0 && stats.neutronCount === 0 || isReactionOver) {
                resetSimulation();
                return; 
            }

            // Only start if no neutrons are currently in motion
            if (stats.neutronCount > 0) return; 

            const remainingFissileAtoms = atoms.filter(a => a.isFissile);
            if (remainingFissileAtoms.length === 0) return;

            // --- Logic: Target all but 2-5 atoms in every Z-Row (plane) ---
            
            const MIN_SURVIVORS_PER_ROW = 2;
            const MAX_SURVIVORS_PER_ROW = 5;

            let targets = [];
            let destructionPlan = []; // For logging to prove uniform destruction

            // 1. Group atoms by Z-coordinate (row)
            const atomsByZ = remainingFissileAtoms.reduce((acc, atom) => {
                // Use fixed decimal to reliably group atoms in the same plane
                const z = atom.mesh.position.z.toFixed(2); 
                if (!acc[z]) acc[z] = [];
                acc[z].push(atom);
                return acc;
            }, {});

            // 2. Iterate through each row (Z-plane) and select survivors/targets
            // This loop ensures every row is treated equally.
            const zKeys = Object.keys(atomsByZ).sort(); // Sort keys for clearer console output
            
            for (const z of zKeys) {
                const rowAtoms = atomsByZ[z];
                // Shuffle the row atoms
                const shuffledRow = [...rowAtoms].sort(() => 0.5 - Math.random());
                
                // Determine the number of survivors (2 to 5)
                const numSurvivors = Math.floor(Math.random() * (MAX_SURVIVORS_PER_ROW - MIN_SURVIVORS_PER_ROW + 1)) + MIN_SURVIVORS_PER_ROW; 

                // All atoms *after* the first 'numSurvivors' in the shuffled list are targets for destruction
                const rowTargets = shuffledRow.slice(numSurvivors); 

                targets.push(...rowTargets);
                
                // Log the plan for this row
                destructionPlan.push({
                    z: parseFloat(z),
                    totalAtoms: rowAtoms.length,
                    survivors: numSurvivors,
                    targets: rowTargets.length
                });
            }

            // --- Logging for Transparency ---
            console.log("--- INITIAL DESTRUCTION PLAN ---");
            console.log(`Total Atoms to be Targeted: ${targets.length}`);
            console.table(destructionPlan.map(p => ({
                'Z-Position': p.z,
                'Total': p.totalAtoms,
                'Targets': p.targets,
                'Survivors': p.survivors
            })));
            console.log("----------------------------------");
            // --- End Logging ---

            // 3. Launch one neutron directly at every target atom for instant fission.
            
            // Start the reaction timer
            reactionStartTime = performance.now();
            isReactionOver = false;

            for (const targetAtom of targets) {
                const atomPos = targetAtom.mesh.position;
                
                // Determine a random approach vector (from where the neutron will come)
                const approachVector = new THREE.Vector3().randomDirection(); 

                // Calculate the starting position (just outside the collision margin for guaranteed strike)
                // URANIUM_RADIUS 3.0 + Neutron_Radius 0.3 + 0.1 epsilon = 3.4
                const launchDistance = URANIUM_RADIUS + 0.3 + 0.1; 
                // Set start position on the atom's surface + a small margin, in the direction of the approach vector
                const startPosition = atomPos.clone().addScaledVector(approachVector, launchDistance);

                // Calculate the velocity (directed exactly towards the atom center)
                const velocity = approachVector.negate().multiplyScalar(INITIAL_LAUNCH_VELOCITY);

                particles.push(new MovingParticle('neutron', startPosition, velocity, 0.3, materials.neutron));
                stats.neutronCount++; 
            }

            // --- END NEW LOGIC ---

            startButton.disabled = true;
            startButton.innerText = 'Reaction In Progress...';
        }

        let clock = new THREE.Clock();
        function animate() {
            requestAnimationFrame(animate);

            const deltaTime = clock.getDelta();
            controls.update();
            
            // --- PARTICLE UPDATE LOGIC ---

            // Only update non-fission products (neutrons) and check for collisions if the reaction is NOT over.
            if (!isReactionOver) {
                // Particle speed multiplier for faster chain reaction spread.
                for (let i = particles.length - 1; i >= 0; i--) {
                    particles[i].update(deltaTime * SIMULATION_SPEED_MULTIPLIER); 
                }
                checkCollisions();
            } else {
                // If the reaction is over, only allow existing fission products to continue moving/fading out.
                // Neutrons (type 'neutron') were cleaned up by cleanupFrozenNeutrons()
                for (let i = particles.length - 1; i >= 0; i--) {
                    if (particles[i].type === 'fission_product') {
                        particles[i].update(deltaTime * SIMULATION_SPEED_MULTIPLIER);
                    }
                }
            }


            // Update and clean up explosion particles (Fireball fade-out effect always runs)
            for (let i = explosionParticles.length - 1; i >= 0; i--) {
                if (explosionParticles[i].update(deltaTime)) {
                    explosionParticles[i].destroy();
                    explosionParticles.splice(i, 1);
                }
            }

            updateInfoDisplay();

            renderer.render(scene, camera);
        }

        function updateInfoDisplay() {
            document.getElementById('fissionCount').innerText = stats.fissionCount;
            // The neutron count display is now handled within cleanupFrozenNeutrons() when the reaction ends.

            const startButton = document.getElementById('startButton');

            // Check for all stopping conditions
            const isTimeUp = reactionStartTime !== null && (performance.now() - reactionStartTime) / 1000 >= TIME_LIMIT_SECONDS;
            
            // Condition for natural fizzle: Neutrons have run out AND fissions occurred
            const reactionFizzled = stats.neutronCount === 0 && stats.fissionCount > 0;
            
            // Condition for hitting the engineered limit
            const isLimitHit = stats.fissionCount >= currentFissionLimit;
            
            const shouldStop = reactionFizzled || isTimeUp || isLimitHit;

            // Transition to the 'isReactionOver' state
            if (shouldStop && !isReactionOver) {
                isReactionOver = true;
                // Immediately clean up all remaining neutrons (if any are still inside the boundary) 
                // to reset the display counter to 0 instantly.
                cleanupFrozenNeutrons();
            }

            if (isReactionOver) {
                startButton.disabled = false;
                startButton.innerText = 'Reaction Over! (Reset)';
                
            } else if (stats.neutronCount === 0 && stats.fissionCount === 0) {
                // Initial state
                startButton.disabled = false;
                startButton.innerText = 'Start Reaction';
            } else {
                // Update neutron count display continuously only if reaction is running
                document.getElementById('neutronCount').innerText = stats.neutronCount;
            }
            
            // If the reaction is running, the button remains disabled and says "Reaction In Progress..."
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        window.onload = function() {
            init();
            animate();
        };

    </script>
</body>
</html>
